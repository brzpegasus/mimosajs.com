<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Modules - Mimosa</title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- <link rel="stylesheet" href="css/main.css"> -->
  <link rel="stylesheet" href="css/bootstrap.min.css" >
  <link rel="stylesheet" href="css/bootstrap-responsive.min.css" >
  <link rel="stylesheet" href="css/app.css">

  <link rel="shortcut icon" href="img/favicon.ico">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="img/apple-touch-icon-144-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="img/apple-touch-icon-114-precomposed.png">
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="img/apple-touch-icon-72-precomposed.png">
  <link rel="apple-touch-icon-precomposed" href="img/apple-touch-icon-57-precomposed.png">
</head>
<body data-spy="scroll" data-target=".subnav" data-offset="50">

  <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <div class="nav-collapse collapse">
          <ul class="nav">
            <li class="">
              <a href="./index.html">Mimosa</a>
            </li>
            <li class="">
              <a href="./started.html">Get Started</a>
            </li>
            <li class="">
              <a href="./commands.html">Commands</a>
            </li>
            <li class="">
              <a href="./compilers.html">Compilers</a>
            </li>
            <li  class="active">
              <a href="./modules.html">Extend: Modules</a>
            </li>
            <li class="">
              <a href="./server.html">Serve</a>
            </li>
            <li class="">
              <a href="./utilities.html">Utilities</a>
            </li>
            <li class="">
              <a href="./optimization.html">Optimization</a>
            </li>
            <li class="">
              <a href="./configuration.html">Configuration</a>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

<div class="container main">

  <header class="jumbotron subhead" id="overview">
    <h1>Modules</h1>
    <p class="lead">Extend Mimosa's default functionality, and publish your own extensions</p>
    <div class="subnav">
      <ul class="nav nav-pills">
        <li><a href="#overview" title="Module commands">Overview</a></li>
        <li><a href="#commands" title="Module commands">Module Commands</a></li>
        <li><a href="#create" title="Create a new project">Create Module</a></li>
        <li><a href="#register" title="Register your Module">Module Registration</a></li>
        <li><a href="#callback" title="Your Module Callback, Where Your Code Gets Called">Module Callback</a></li>
        <li><a href="#install" title="How to get Mimosa to know about your Module">Module Installing</a></li>
      </ul>
    </div>
  </header>

  <section class="command-list">
    <div class="page-header" id="overview">
      <h1>
        What is a Module? <small><span class="options">Mimosa is the car, modules let you drive</span></small>
      </h1>
    </div>

    <p>So maybe Mimosa doesn't come with exactly what you need out of the box.  Maybe you want to use a different linter than Mimosa comes bundled with, or you want to kick off your testing suite on every file save. A module can probably help.</p>

    <p>A Mimosa module is a node.js project that, when installed inside Mimosa, can be used as part of Mimosa's workflow. Mimosa is able to use a module because modules implement a simple interface that Mimosa can access.</p>

    <p>There's a strong chance that what you need can be created as a new module.  Modules include themselves in a Mimosa workflow to perform their task, and in some cases all you need to do is add the name of the module you want to your configuration and start Mimosa. Mimosa self-installs modules it comes across but does not already have installed.</p>

    <p>Modules were introduced on Nov 1, during beta, so don't expect a flourishing ecosystem just yet.  But someday there's a chance that the functionality you want to perform will reside in an existing module. You just need to track it down.  And Mimosa can help you there too.  Read on!</p>

    <div class="page-header" id="commands">
      <h1>
        List Installed Modules
        <small><span class="mim">mimosa</span> <span class="command">mod:list</span> <span class="options">[-v/--verbose]</span></small>
      </h1>
    </div>
    <div class="row">
      <div class="span6">
        <h2>mod:list</h2>

        <p>Execute <code class='option'>mod:list</code> to see a list of all the Mimosa modules installed with your Mimosa.  The list that is displayed includes the name, the version, and the URL of the website from which the module originated.</p>

        <pre>$ mimosa mod:list</pre>

        <h3>Get more details (-v/--verbose)</h3>

        <p>Add a <code class="option">--verbose</code> flag and Mimosa will include additional information including a short description and the list of dependencies the module has on other node.js modules.</p>

        <pre>$ mimosa mod:list --verbose</pre>

      </div>

      <div class="span6 term">
        <div class="inner">
          <p>
            Davids-MacBook-Pro:webapp dbashford$ mimosa mod:list<br/><br/>
            <span class="inst">The following is a list of the Mimosa modules you have installed.</span><br/><br/>
            <span class="fb">Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Version&nbsp;&nbsp;&nbsp;Website</span><br/>
            <span class="inst">mimosa-server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.2.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.mimosajs.com</span><br/>
            <span class="inst">mimosa-require&nbsp;&nbsp;&nbsp;&nbsp;0.2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.mimosajs.com</span><br/>
            <span class="inst">mimosa-minify&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.mimosajs.com</span><br/>
            <span class="inst">mimosa-lint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.2.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.mimosajs.com</span><br/><br/>
            <span class="inst">To view more module details, execute 'mimosa mod:list -v' for 'verbose' logging. </span><br/><br/>
            Davids-MacBook-Pro:webapp dbashford$<br/>
          </p>
        </div>
      </div>
    </div>
    <div class="page-header">
      <h1>
        Search NPM for Modules
        <small><span class="mim">mimosa</span> <span class="command">mod:search</span> <span class="options">[-v/--verbose]</span></small>
      </h1>
    </div>
    <div class="row">
      <div class="span6">
        <h2>mod:search</h2>

        <p><code class='option'>mod:search</code> will make a trip out to <a href="https://npmjs.org/">NPM</a> to search for all the Mimosa modules that are available for install. This command can take some time as it talks over HTTP to NPM, finding all available modules and then narrowing down the list to just those prefixed with 'mimosa-'.</p>

        <pre>$ mimosa mod:search</pre>

        <p>Included in the list of modules is the name, the current version, the last time it was updated, whether or not you already have it installed, and a website for the module.</p>

        <h3>Get more details (-v/--verbose)</h3>

        <p>Add a <code class="option">--verbose</code> flag and Mimosa will include additional information including a short description and the list of dependencies the module has on other node.js modules.</p>

        <pre>$ mimosa mod:search --verbose</pre>

      </div>

      <div class="span6 term">
        <div class="inner">
          <p>
            Davids-MacBook-Pro:webapp dbashford$ mimosa mod:search<br/><br/>

            <span class="inst">Searching NPM for Mimosa modules, this might take a few seconds...</span><br/><br/>

            <span class="inst">The following is a list of the Mimosa modules in NPM.</span><br/><br/>

            <span class="fb">Name &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Version&nbsp;Updated&nbsp;&nbsp;&nbsp;&nbsp;Installed?&nbsp;Website</span><br/>
            <span class="inst">mimosa-logger&nbsp;&nbsp;0.1.0
              &nbsp;&nbsp;2012-10-21 no        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          http://www.mimosajs.com
            </span><br/>
            <span class="inst">mimosa-server&nbsp;&nbsp;0.2.1
              &nbsp;&nbsp;2012-10-25 yes
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              http://www.mimosajs.com
            </span><br/>
            <span class="inst">mimosa-lint&nbsp;&nbsp;&nbsp;&nbsp;0.2.0
              &nbsp;&nbsp;2012-10-24 yes
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.mimosajs.com
            </span><br/>
            <span class="inst">mimosa-require&nbsp;0.2.0
              &nbsp;&nbsp;2012-10-24 yes &nbsp;&nbsp;
              &nbsp;&nbsp;&nbsp;&nbsp;http://www.mimosajs.com
            </span><br/>
            <span class="inst">mimosa-minify&nbsp;&nbsp;0.2.0
              &nbsp;&nbsp;2012-10-24 yes
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              http://www.mimosajs.com
            </span><br/><br/>

            <span class="inst">To view more module details, execute 'mimosa mod:search -v' for 'verbose' logging.</span><br/><br/>

            <span class="inst">Install modules by executing 'mimosa mod:install [name of module]'</span><br/><br/>

            Davids-MacBook-Pro:webapp dbashford$<br/>
          </p>
        </div>
      </div>
    </div>
    <div class="page-header">
      <h1>
        Install a Module
        <small><span class="mim">mimosa</span> <span class="command">mod:install</span> <span class="options">[moduleName]</span></small>
      </h1>
    </div>
    <div class="row">
      <div class="span6">
        <h2>mod:install</h2>

        <p>Once you have found a module you want to install in your Mimosa, execute <code class='option'>mod:install</code> and give the command the name of the module.</p>

        <pre>$ mimosa mod:install mimosa-server</pre>

        <p>If the module has already been installed, this will update it to the latest version.  If you want to get a specific version of a module, add the version after a @.</p>

        <pre>$ mimosa mod:install mimosa-server@0.2.0</pre>

        <p>If you are developing a module and want to use and test it locally without pushing to NPM first, then execute <code class='option'>mod:install</code> without providing a name for the module.  For this to work properly, you will want to be in the same directory as the package.json, which should be the base directory of your module.  Once Mimosa installs your module, Mimosa treats it the same as a module it installed from NPM.</p>

      </div>

      <div class="span6 term">
        <div class="inner">
          <p>
            Davids-MacBook-Pro:webapp dbashford$ mimosa mod:install mimosa-server@0.2.0<br/><br/>

            <span class="inst">09:57:43 - Install of 'mimosa-server@0.2.0' successful</span> <br/><br/>

            Davids-MacBook-Pro:webapp dbashford$
          </p>
        </div>
      </div>
    </div>
    <div class="page-header">
      <h1>
        Uninstall a Module
        <small><span class="mim">mimosa</span> <span class="command">mod:uninstall</span></small>
      </h1>
    </div>
    <div class="row">
      <div class="span6">
        <h2>mod:uninstall</h2>

        <p>Execute <code class='option'>mod:uninstall</code> to remove a module from Mimosa so Mimosa is unable to use it on any projects.</p>

        <pre>$ mimosa mod:uninstall mimosa-server</pre>

      </div>

      <div class="span6 term">
        <div class="inner">
          <p>
            Davids-MacBook-Pro:webapp dbashford$ mimosa mod:uninstall mimosa-server<br/><br/>

            <span class="inst">09:57:43 - Uninstall of 'mimosa-server' successful</span> <br/><br/>

            Davids-MacBook-Pro:webapp dbashford$
          </p>
        </div>
      </div>
    </div>
    <div class="page-header">
       <h1>
         Initialize Your Own Module
         <small><span class="mim">mimosa</span> <span class="command">mod:init</span> <span class="options">[nameOfModule]</span> <span class="options">[-j/--javascript]</span></small>
       </h1>
     </div>
     <div class="row">
       <div class="span6">
         <h2>mod:init</h2>

         <p>Execute <code class='option'>mod:init</code> and provide the command with a 'mimosa-' prefixed name for your module and Mimosa will create a directory using the name (or use one if it already exists), and place a module skeleton inside.  The skeleton contains heavily documented CoffeeScript code to get you started, docco-generated documentation for that code, and a starter <code class='option'>package.json</code> to get you ready for deploying your module to <a href="https://npmjs.org/">NPM</a>.</p>

         <p>You'll want to go into the <code class='option'>package.json</code> and change all of the placeholders.  The following sections go into detail about how to create your own module.</p>

         <pre>$ mimosa mod:init mimosa-foo</pre>

         <h3>Prefer JavaScript? (-j/--javascript)</h3>

         <p>Add a <code class="option">--javascript</code> flag and Mimosa will give you a JavaScript skeleton instead of the CoffeeScript one.</p>

         <pre>$ mimosa mod:init -j
$ mimosa mod:init --javascript</pre>

       </div>

       <div class="span6 term">
         <div class="inner">
           <p>
             Davids-MacBook-Pro:mimosaplay dbashford$ mimosa mod:init mimosa-foo<br/><br/>

             <span class="inst">10:06:59 - Module skeleton successfully placed in mimosa-foo directory. The first thing you'll want to do is go into mimosa-foo/package.json and replace the placeholders.</span> <br/><br/>

             Davids-MacBook-Pro:mimosaplay dbashford$
           </p>
         </div>
       </div>
     </div>

    <div class="page-header" id="create">
      <h1>
        Create Your Own Module
        <small><span class="options">getting off the ground</span></small>
      </h1>
    </div>

    <h2>Where to start?</h2>

    <p>Mimosa can help you get off the ground with a module skeleton.  Discussed above, the <code class='option'>mod:init</code> command will create a skeleton for you and place it in the directory of your choice.  The only hard and fast rule with Mimosa modules is that when they are created they be prefixed with 'mimosa-'. This makes them easy to find if someone else wants to use them, but also differentiates Mimosa's modules from all of the libraries both in <a href="https://npmjs.org/">NPM</a> and inside Mimosa.</p>

    <p>One great place to start, if you want to skip reading and get right to code, is to check out some existing modules, like <a href="https://github.com/dbashford/mimosa-lint">mimosa-lint</a>
 and <a href="https://github.com/dbashford/mimosa-minify">mimosa-minify</a>.</p>


    <h2>What does mod:init give me?</h2>

    <p><code class='option'>mod:init</code> gives you a group of files to get you started.</p>

    <ul>
      <li><code class='option'>package.json</code>: If you are familiar with node.js, you know what this is.  This defines all sorts of metadata about your node project.  It's name, the dependencies, the repo location, a description, etc.  When you publish your module to <a href="https://npmjs.org/">NPM</a>, NPM expects the <code class='option'>package.json</code> to be present.  The <code class='option'>package.json</code> that Mimosa gives you needs some editing.  You will want to go into this file and change a few things, or at least take out the placeholders.</li>
      <li><code class='option'>index.coffee</code>: This highly commented file defines a module's interface to Mimosa.  Mimosa will pull this file in and use it to execute a module's functions.  This is a possible location for your module code, the code that actually performs your modules task.  Or you could put that code in a new file and pull it into the <code class='option'>index</code> file. That's up to you. How your module is structured is entirely up to you, as long as the functions Mimosa expects are made available (exported in node speak) in the <code class='option'>index</code> file.</li>
      <li><code class='option'>config.coffee</code>: This highly commented file contains three functions for you to implement.  A function that returns the default configuration, a function that returns a string placeholder for the <code class='option'>mimosa-config</code>, and a function to validate a user's configuration for your module.  Mimosa calls these functions at different times.  If you have no configuration at all, you can remove the functions and the file.  Or leave it all and just comment the code out in case you might introduce configuration later.</li>
      <li>A <code class='option'>docs</code> folder: Using a tool called a <a href="http://jashkenas.github.com/docco/">Docco</a> the comments in the <code class='option'>config</code> and <code class='option'>index</code> files have been turned into easy to read web pages, with comments along side code. This is the real place to start.  Read through the the docco pages and get comfy with the concepts.</li>
    </ul>

    <h2>Mimosa module interface</h2>

    <p>At different times, Mimosa will attempt to call four different functions in a module.  All of the functions are optional.</p>

    <h3>defaults()</h3>
    <p>A module's <code class='option'>defaults</code> function is called when Mimosa starts up and is used to assemble the configuration used by Mimosa.  <code class='option'>defaults</code> should return a JavaScript object that is the default configuration for the module.  That default configuration is merged with the user provided configuration to establish the full <code class='option'>mimosa-config</code>.</p>

    <pre>exports.defaults = ->
  minify:
    exclude:["\\.min\\."]</pre>

    <p>If your module doesn't have its own configuration, then this function does not need to be implemented.</p>

    <h3>placeholder()</h3>
    <p>A module's <code class='option'>placeholder</code> function is called when Mimosa is building the <code class='option'>mimosa-config.coffee</code> file that is delivered to a user during both the <code class='option'>mimosa new</code> and <code class='option'>mimosa config</code> commands. Use this function to return a string that shows what the module's configuration is and then explains each setting.  For example:</p>

    <pre>exports.placeholder = ->
  """
  \t
    # minify:                   # Configuration for non-require minification/compression via uglify
                                 # using the --minify flag.
      # exclude:["\\\\.min\\\\."]     # List of regexes to exclude files when running minification.
                                 # Any path with ".min." in its name, like jquery.min.js, is assumed to
                                 # already be minified and is ignored by default. Override this property
                                 # if you have other files that you'd like to exempt from minification.
  """</pre>

    <p>If your module doesn't have its own configuration, then this function does not need to be implemented.</p>

    <h3>validate(mimosaConfig)</h3>
    <p>A module's <code class='option'>validate</code> function is called when Mimosa starts up and after Mimosa has put together the full <code class='option'>mimosa-config</code>.  That full config is passed to the validate method of all modules and each module has the opportunity to ensure that the config settings are ok. This method should return an array of strings. Each string represents an error that the module has found with the config. If you return any errors, Mimosa will print your errors and exit to give the user a chance to update the config.</p>
    <p>If there are no errors, return an empty array.  If there is no config to validate, then do not implement the method.</p>
    <p>This method is also an opportunity to transform the data if need be.  For example, you can take a list of strings and turn them into RegExp objects.</p>

    <pre>
exports.validate = (config) ->
  errors = []
  if config.minify?
    if typeof config.minify is "object" and not Array.isArray(config.minify)
      if config.minify.exclude?
        if Array.isArray(config.minify.exclude)
          for ex in config.minify.exclude
            unless typeof ex is "string"
              errors.push "minify.exclude must be an array of strings"
              break
        else
          errors.push "minify.exclude must be an array."
    else
      errors.push "minify configuration must be an object."

  if errors.length is 0 and config.minify.exclude?.length > 0
    config.minify.exclude = new RegExp config.minify.exclude.join("|"), "i"

  errors</pre>

    <h3>registration(mimosaConfig, register)</h3>

    <p>The <code class='option'>registration</code> function is the key part of your module. This function is called during Mimosa's startup and it allows your module to bind to one or many steps in a Mimosa workflow.</p>

    <p>The arguments passed in are:</p>
    <ul>
      <li>mimosaConfig: The full <code class='option'>mimosa-config</code> including added flags to indicate what sort of Mimosa command is being run (like isForceClean, or isVirgin), and an added list of extensions being used by the application. You may decide based on the flags in the config to not register anything, which is fine. In the case of the minification example below, if the isMinify flag isn't turned on then the module doesn't register itself.</li>
      <li>register: This is a function handed to your module as a means to register your module with Mimosa.  More information about how to use this register function follows in the next section.</li>
    </ul>

    <pre>registration = (mimosaConfig, register) ->
  if mimosaConfig.isMinify
    e = mimosaConfig.extensions
    register ['add','update','buildFile'],      'afterCompile', _minifyJS,  [e.javascript...]
    register ['add','update','buildExtension'], 'beforeWrite',  _minifyJS,  [e.template...]</pre>

    <div class="page-header" id="register">
      <h1>
        Registering Your Module with Mimosa
        <small><span class="options">control when your code gets called</span></small>
      </h1>
    </div>

    <p>As mentioned in the previous section, a module should implement a <code class='option'>registration</code> function that Mimosa calls when it starts up.  When it calls the module's <code class='option'>registration</code> function, Mimosa passes the enriched <code class='option'>mimosa-config</code> and a <code class='option'>register</code> callback.  The <code class='option'>register</code> callback is what a module uses to inform Mimosa what function in the module to call and under what circumstances to call it.  You call the <code class='option'>register</code> callback with the following four parameters:</p>

    <ol>
      <li>A list of workflow types, an array of strings. Pick one-to-many types depending on the sort of task your module accomplishes. Possible values: buildFile, buildExtension, buildDone, add, update, remove.  These are explained below.</li>
      <li>A workflow step, a string. A workflow step for the selected workflow types. For example, for the type 'update', you might choose to have your module code executed 'afterCompile'.  The list of steps for each type is explained below.</li>
      <li>Your module callback, a function. This is the module function Mimosa will call when processing reaches the type(s) and step called out in the previous parameters.</li>
      <li>An optional array of extensions upon which to execute the callback. If the file or extension being processed doesn't match one of these extensions, the callback will not be executed. The extensions refer to the original extension of the file being processed, so in the case of a CoffeeScript file it would be 'coffee' and not 'js'. The passed in <code class='option'>mimosaConfig</code> object has an <code class='option'>extensions</code> object you can use to cover all of the desired extensions. The <code class='option'>extensions</code> object has 4 properties: <code class='option'>javascript</code>, <code class='option'>css</code>, <code class='option'>template</code>, and <code class='option'>copy</code>. If no extensions are provided, Mimosa will send all files/extensions through the module.</li>
    </ol>

    <pre>register ['add','update','buildFile'],      'afterCompile', _minifyJS,  [e.javascript...]
register ['add','update','buildExtension'], 'beforeWrite',  _minifyJS,  [e.template...]</pre>

    <h2>Workflow Types <small><span class="options">buildFile, buildExtension, buildDone, add, update, remove</span></small></h2>

    <p>A workflow type represents a workflow an asset, a group of assets, or your application can go through.  <code class="options">add</code>, <code class="options">update</code>, and <code class="options">remove</code> are workflow types, in this case for individual assets, and as such they each have their own workflow that Mimosa runs through.</p>

    <p>There are six workflow types and they are essentially broken up into two groups.  There are those types that apply to Mimosa's startup, and those that apply to post-startup.</p>

    <h3>Startup Types</h3>

    <p>The startup types are all prefixed with 'build', and they all occur in order during Mimosa's startup.  <code class="options">buildFile</code> occurs first, <code class="options">buildExtension</code> second, and lastly <code class="options">buildDone</code>.
    </p>

    <h4>buildFile</h4>
    <p>When Mimosa first starts up, it goes through every asset in the configured <code class="options">watch.sourceDir</code> and passes each one through buildFile processing.  It is during buildFile processing that, for instance, CoffeeScript files are compiled to JavaScript and written to <code class="options">watch.compiledDir</code>.  It is also when your images are copied to the <code class="options">watch.compiledDir</code>.</p>

    <p>Some assets, like micro-templates files and pre-compiler CSS files (like SASS or LESS) are not processed during this step as they, during startup, need to be dealt with as a group rather than individually.</p>

    <h4>buildExtension</h4>
    <p>After all of the assets are processed individually, <code class="options">buildExtension</code> makes another pass through all your assets, but this time for extension-wide processing. </p>

    <p>Why extension processing?  Well, as an example, during <code class="options">buildFile</code> Mimosa doesn't process your micro-templates at all. There's no point. Their handling during startup is an extension-wide event. Mimosa needs to compile all of a given type of template at once and push them into a single file.</p>

    <p>Same thing for CSS. If a project uses something like SASS, then it might have 20 includes/partials that result in 2 top-level files actually being compiled. There's no point in Mimosa compiling each partial, so instead Mimosa deals with all SASS files at once during extension processing, compiling just the base files.</p>

    <h4>buildDone</h4>

    <p>After the extensions are finished, the assets have been dealt with. <code class="options">buildDone</code> is when post asset completion tasks take place. For instance, it is when asset optimization occurs.  It is also when servers are started if that option was selected. If you were building your own module for something like installing the built app to Heroku, then <code class="options">buildDone</code> is where that would be done as well.</p>

    <h3>Post-Startup Types</h3>

    <p>If you are just running <code class="options">mimosa build</code>, then after <code class="options">buildDone</code> finishes, Mimosa exits.  If you are running <code class="options">mimosa virgin</code> or <code class="options">mimosa watch</code>, then Mimosa keeps running and waits for you to make changes to assets so it can kick off the post-startup workflow types.  These are very self-explanatory.</p>

    <p>For Post-Startup Types there is no delineation between file and extension as it is unnecessary.  For each type only a single file is being processed at a time.  So modules like the CSS and micro-templates compilers perform extension wide tasks based on the single file that was updated.</p>

    <h4>add</h4>
    <p>The <code class="options">add</code> workflow type is kicked off when a new file is dropped into your <code class="options">watch.sourceDir</code> directory.</p>

    <h4>update</h4>
    <p>The <code class="options">update</code> workflow type is kicked off when an existing file in your <code class="options">watch.sourceDir</code> directory is saved.</p>

    <h4>remove</h4>
    <p>The <code class="options">remove</code> workflow type is kicked off when a file in your <code class="options">watch.sourceDir</code> directory is deleted.</p>

    <h2>Workflow Steps <small><span class="options">a list of processing steps for each workflow type</span></small></h2>

    <p>The previous section covered each different workflow type.  Within each workflow type are many steps to the the workflow.  An example is the best way to illustrate how this works.</p>

    <p>The simplest workflow type is <code class="options">update</code>.  Lets say you save a CoffeeScript file inside your <code class="options">watch.sourceDir</code> while Mimosa is running.  Here's what happens:</p>

    <ol>
      <li>The first step executed is <code class="options">init</code>. During the <code class="options">init</code> step, Mimosa will generate some information about the asset to be used by future steps. For instance it will set a flag into the <code class="options">options</code> object (discussed in the next section) to indicate that the file is a JavaScript file, and it will set flags to indicate if the file is a vendor file or not.</li>
      <li>During a step named <code class="options">read</code> the modified CoffeeScript file is read in.</li>
      <li>The <code class="options">compile</code> step is next.  Here the CoffeeScript gets compiled to JavaScript.</li>
      <li>Next is <code class="options">afterCompile</code>.  Here the compiled JavaScript is linted to get feedback regarding code quality.</li>
      <li>If minification was selected, <code class="options">beforeWrite</code> is where the compiled JavaScript would be minified.</li>
      <li>During the <code class="options">write</code> step the compiled JavaScript is written to the <code class="options">watch.compiledDir</code></li>
      <li>You'd think we'd be done now, but not so fast!  The <code class="options">afterWrite</code> step is where optimization takes place if you have that selected.</li>
    </ol>

    <p>And there are many steps in this example that have no functionality registered against them.  The <code class="options">beforeRead</code>, <code class="options">afterRead</code>, <code class="options">beforeCompile</code>, and <code class="options">complete</code> steps for the <code class="options">update</code> workflow have no modules that execute against them, but they are there in the event a module comes along that logically has tasks to perform in those workflow areas.</p>

    <p>Also, many modules can register to be executed for the same type and step, they'll just be executed in order that they get registered.</p>

    <p>When building a module, you need to decide which step is the right place to execute your code.  For instance, if you are building a module that will run <a href="http://www.coffeelint.org/">CoffeeLint</a> over your CoffeeScript to determine CoffeeScript code quality, then you probably want to do that as part of the <code class="options">afterRead</code> step.  If you do it as part of the <code class="options">beforeRead</code> step, then Mimosa will have not yet read in the file, and you'll have nothing to run CoffeeLint on.</p>

    <p>Below is the exhaustive list of all of the steps by type.  Use the radio buttons to toggle between the different default Mimosa modules, and to toggle file types.  Some modules do things without regard to extension, usually during <code class="options">buildDone</code> and the last File Type option covers those instances.</p>

    <br/>

    <p>
      <span class="radio-heading">Modules: </span><input type="radio" name="module" value="builtin"> Mimosa's Built-In Compiler and File Modules
      <input type="radio" name="module" value="server"> server
      <input type="radio" name="module" value="require"> require
      <input type="radio" name="module" value="minify"> minify
      <input type="radio" name="module" value="lint"> lint
    </p>

    <p>
      <span class="radio-heading">File Types: </span><input type="radio" name="extension" value="js"> JavaScript
      <input type="radio" name="extension" value="css"> CSS
      <input type="radio" name="extension" value="template"> Micro-Templates
      <input type="radio" name="extension" value="copy"> Copied Files
      <input type="radio" name="extension" value="not"> Not Extension Based
    </p>

    <div class="row workflow-steps">
      <div class="span2">
        <h3>buildFile</h3>
        <ul>
          <li>
            <div class="step">init</div>
            <div class="module js copy builtin">(JS, C) options.files array created with single file with inputFileName and outputFileName</div>
          </li>
          <li>
            <div class="step">beforeRead</div>
            <div class="module js copy builtin">(JS, C) Determine if file needs to be processed, exit workflow if not</div>
          </li>
          <li>
            <div class="step">read</div>
            <div class="module builtin copy js">(JS, C) options.files. inputFileName read into options.files. inputFileText</div>
          </li>
          <li>
            <div class="step">afterRead</div>
          </li>
          <li>
            <div class="step">betweenReadCompile</div>
          </li>
          <li>
            <div class="step">beforeCompile</div>
          </li>
          <li>
            <div class="step">compile</div>
            <div class="module builtin copy">(C) options.files. inputFileText moved to options.files. outputFileText</div>
            <div class="module builtin js">(JS) options.files. inputFileText compiled to options.files. outputFileText</div>
          </li>
          <li>
            <div class="step">afterCompile</div>
            <div class="module lint copy">(C) For copied (not compiled) CSS files, options.files. outputFileText is linted, errors printed to console</div>
            <div class="module lint copy js">(JS, C) For JS and copied JS, options.files. outputFileText is linted, errors printed to console</div>
            <div class="module require js">(JS) javascript dependencies in options.files. outputFileText registered with module for future validation</div>
          </li>
          <li>
            <div class="step">betweenCompileWrite</div>
          </li>
          <li>
            <div class="step">beforeWrite</div>
            <div class="module minify js">(JS) If minified flag used, options.files. outputFileText is minified</div>
          </li>
          <li>
            <div class="step">write</div>
            <div class="module builtin js copy">(JS, C) options.files. outputFileText written to compiledDir at options.files. outputFileName</div>
          </li>
          <li>
            <div class="step">afterWrite</div>
          </li>
          <li>
            <div class="step">complete</div>
          </li>
        </ul>
      </div>
      <div class="span2">
        <h3>buildExtension</h3>
        <ul>
          <li>
            <div class="step">init</div>
            <div class="module builtin css template">(CSS, T) options set up with flags (isCSS, isTemplate, etc) and options. destinationFile function created, takes sourceDir file name and returns compiled file name</div>
            <div class="module builtin css">(CSS) Base files determined and base file names that need compiling placed into options.files</div>
            <div class="module builtin template">(T) File names gathered into options.files array, no outputFileName set (as template files are never written)</div>
          </li>
          <li>
            <div class="step">beforeRead</div>
            <div class="module builtin template">(T) All templates checked to see if any need compiling, if not, sets options.files to empty array</div>
          </li>
          <li>
            <div class="step">read</div>
            <div class="module builtin css template">(CSS, T) options.files. inputFileName read into options.files. inputFileText</div>
          </li>
          <li>
            <div class="step">afterRead</div>
          </li>
          <li>
            <div class="step">betweenReadCompile</div>
          </li>
          <li>
            <div class="step">beforeCompile</div>
          </li>
          <li>
            <div class="step">compile</div>
            <div class="module builtin css template">(CSS, T) options.files. inputFileText compiled into options.files. outputFileText</div>
          </li>
          <li>
            <div class="step">afterCompile</div>
            <div class="module builtin template">(T) compiled templates merged into single file, result added as new options.files entry</div>
            <div class="module builtin template">(T) vendor template library read and added to options.files</div>
            <div class="module lint css">(CSS) For compiled CSS files, options.files. outputFileText is linted, errors printed to console</div>
            <div class="module require template">(T) javascript dependencies in options.files. outputFileText registered with module for future validation</div>
          </li>
          <li>
            <div class="step">betweenCompileWrite</div>
          </li>
          <li>
            <div class="step">beforeWrite</div>
            <div class="module minify css template">(CSS, T) If minified flag used, options.files. outputFileText is minified</div>
          </li>
          <li>
            <div class="step">write</div>
            <div class="module builtin template css">(CSS, T) options.files with an outputFileName and outputFileText written to compiledDir</div>
          </li>
          <li>
            <div class="step">afterWrite</div>
          </li>
          <li>
            <div class="step">complete</div>
            <div class="module builtin template">(T) message user if different template libraries used without handling in config</div>
          </li>
        </ul>
      </div>
      <div class="span2">
        <h3>buildDone</h3>
        <ul>
          <li>
            <div class="step">init</div>
          </li>
          <li>
            <div class="step">beforeOptimize</div>
            <div class="module require not">Require module performs codebase path verification for all registered files (templates and js)</div>
          </li>
          <li>
            <div class="step">optimize</div>
            <div class="module require not">If optimize flag used, entire project optimized by r.js</div>
          </li>
          <li>
            <div class="step">afterOptimize</div>
          </li>
          <li>
            <div class="step">beforeServer</div>
          </li>
          <li>
            <div class="step">server</div>
            <div class="module server not">If server flag used, server is started</div>
          </li>
          <li>
            <div class="step">afterServer</div>
          </li>
          <li>
            <div class="step">beforePackage</div>
          </li>
          <li>
            <div class="step">package</div>
          </li>
          <li>
            <div class="step">afterPackage</div>
          </li>
          <li>
            <div class="step">beforeInstall</div>
          </li>
          <li>
            <div class="step">install</div>
          </li>
          <li>
            <div class="step">afterInstall</div>
          </li>
          <li>
            <div class="step">complete</div>
          </li>
        </ul>
      </div>
      <div class="span2">
        <h3>add</h3>
        <ul>
          <li>
            <div class="step">init</div>
            <div class="module builtin css template">(CSS, T) options set up with flags (isCSS, isTemplate, etc) and options. destinationFile function created, takes sourceDir file name and returns compiled file name</div>
            <div class="module builtin css">(CSS) Base file names determined and base files that need compiling placed into options.files</div>
            <div class="module builtin template">(T) File names gathered into options.files array, no outputFileName set (as template files are never written)</div>
            <div class="module builtin js copy">(JS, C) options.files array created with single file with inputFileName and outputFileName</div>
          </li>
          <li>
            <div class="step">beforeRead</div>
            <div class="module builtin template">(T) All templates checked to see if templates need compiling, if not, sets options.files to empty array</div>
            <div class="module js copy builtin">(JS, C) Determine if file needs to be processed, exit workflow if not</div>
          </li>
          <li>
            <div class="step">read</div>
            <div class="module builtin copy js css template">(JS, CSS, T, C) options.files. inputFileName read into file.inputFileText</div>
          </li>
          <li>
            <div class="step">afterRead</div>
          </li>
          <li>
            <div class="step">betweenReadCompile</div>
          </li>
          <li>
            <div class="step">beforeCompile</div>
          </li>
          <li>
            <div class="step">compile</div>
            <div class="module builtin copy">(C) options.files. inputFileText moved to options.files. outputFileText</div>
            <div class="module builtin css template js">(JS, CSS, T) options.files. inputFileText compiled into options.files. outputFileText</div>
          </li>
          <li>
            <div class="step">afterCompile</div>
            <div class="module builtin template">(T) options.files. outputFileText merged into single string and placed into options.files as new file with outputFileName (so will be written)</div>
            <div class="module builtin template">(T) vendor template library name and file text added to options.files</div>
            <div class="module lint css copy">(CSS, C) options.files. outputFileText is linted, errors printed to console</div>
            <div class="module lint copy js">(JS, C) For JS and copied JS, options.files. outputFileText is linted, errors printed to console</div>
            <div class="module require template js">(JS, T) javascript dependencies in options.files. outputFileText registered with module for future validation</div>
          </li>
          <li>
            <div class="step">betweenCompileWrite</div>
          </li>
          <li>
            <div class="step">beforeWrite</div>
            <div class="module minify js css template">(JS, CSS, T) If minified flag used, options.files. outputFileText is minified</div>
          </li>
          <li>
            <div class="step">write</div>
            <div class="module builtin js css template copy">(JS, CSS, T, C) options.files with an outputFileName and outputFileText written to compiledDir</div>
          </li>
          <li>
            <div class="step">afterWrite</div>
            <div class="module require js template">(JS, T) If optimize flag used, base files relating to originally changed file are optimized by r.js</div>
          </li>
          <li>
            <div class="step">complete</div>
          </li>
        </ul>
      </div>
      <div class="span2">
        <h3>update</h3>
        <ul>
          <li>
            <div class="step">init</div>
            <div class="module builtin css template">(CSS, T) options set up with flags (isCSS, isTemplate, etc) and options. destinationFile function created, takes sourceDir file name and returns compiled file name</div>
            <div class="module builtin css">(CSS) Base file names determined and base files that need compiling placed into options.files</div>
            <div class="module builtin template">(T) File names gathered into options.files array, no outputFileName set (as template files are never written)</div>
            <div class="module builtin js copy">(JS, C) options.files array created with single file with inputFileName and outputFileName</div>
          </li>
          <li>
            <div class="step">beforeRead</div>
            <div class="module builtin template">(T) All templates checked to see if templates need compiling, if not, sets options.files to empty array</div>
            <div class="module js copy builtin">(JS, C) Determine if file needs to be processed, if not exit workflow</div>
          </li>
          <li>
            <div class="step">read</div>
            <div class="module builtin copy js css template">(JS, CSS, T, C) options.files. inputFileName read into file.inputFileText</div>
          </li>
          <li>
            <div class="step">afterRead</div>
          </li>
          <li>
            <div class="step">betweenReadCompile</div>
          </li>
          <li>
            <div class="step">beforeCompile</div>
          </li>
          <li>
            <div class="step">compile</div>
            <div class="module builtin copy">(C) options.files. inputFileText moved to options.files. outputFileText</div>
            <div class="module builtin css template js">(JS, CSS, T) options.files. inputFileText compiled into options.files. outputFileText</div>
          </li>
          <li>
            <div class="step">afterCompile</div>
            <div class="module builtin css">(CSS) source directory analyzed to redetermine base files</div>
            <div class="module builtin template">(T) options.files. outputFileText merged into single string and placed into options.files as new file with outputFileName (so will be written)</div>
            <div class="module builtin template">(T) vendor template library name and file text added to options.files</div>
            <div class="module lint css copy">(CSS, C) options.files. outputFileText is linted, errors printed to console</div>
            <div class="module lint copy js">(JS, C) For JS and copied JS, options.files. outputFileText is linted, errors printed to console</div>
            <div class="module require template js">(JS, T) javascript dependencies in options.files. outputFileText registered with module for future validation</div>
          </li>
          <li>
            <div class="step">betweenCompileWrite</div>
          </li>
          <li>
            <div class="step">beforeWrite</div>
            <div class="module minify js css template">(JS, CSS, T) If minified flag used, options.files. outputFileText is minified</div>
          </li>
          <li>
            <div class="step">write</div>
            <div class="module builtin js css template copy">(JS, CSS, T, C) options.files with an outputFileName and outputFileText written to compiledDir</div>
          </li>
          <li>
            <div class="step">afterWrite</div>
            <div class="module require js template">(JS, T) If optimize flag used, base files relating to originally changed file are optimized by r.js</div>
          </li>
          <li>
            <div class="step">complete</div>
          </li>
        </ul>
      </div>
      <div class="span2">
        <h3>remove</h3>
        <ul>
          <li>
            <div class="step">init</div>
            <div class="module builtin css template">(CSS, T) options set up with flags (isCSS, isTemplate, etc) and options. destinationFile function created, takes sourceDir file name and returns compiled file name</div>
            <div class="module builtin css">(CSS) base file names determined, base files that need compiling placed into options.files</div>
            <div class="module builtin template">(T) File names gathered into options.files array, no outputFileName set (as template files are never written)</div>
            <div class="module builtin js copy">(JS, C) options.files array created with single file with inputFileName and outputFileName</div>
            <div class="module builtin template">(T) During clean, template file and vendor library removed</div>
            <div class="module builtin template">(T) if no templates remain template file and vendor library removed</div>
          </li>
          <li>
            <div class="step">beforeRead</div>
          </li>
          <li>
            <div class="step">read</div>
            <div class="module builtin css template">(CSS, T) options.files. inputFileName read into file.inputFileText</div>
          </li>
          <li>
            <div class="step">afterRead</div>
          </li>
          <li>
            <div class="step">beforeDelete</div>
          </li>
          <li>
            <div class="step">delete</div>
            <div class="module builtin css template">(CSS, T) options.files. inputFileText compiled into options.files. outputFileText</div>
            <div class="module builtin copy js css">(JS, CSS, C) files removed from source directory are removed from compiled directory if they exist</div>
          </li>
          <li>
            <div class="step">afterDelete</div>
            <div class="module require js">(JS) file removed from require module registry</div>
          </li>
          <li>
            <div class="step">beforeCompile</div>
          </li>
          <li>
            <div class="step">compile</div>
          </li>
          <li>
            <div class="step">afterCompile</div>
            <div class="module builtin css">(CSS) source directory analyzed to redetermine base files</div>
            <div class="module builtin template">(T) options.files. outputFileText merged into single string and placed into options.files as new file with outputFileName (so will be written)</div>
          </li>
          <li>
            <div class="step">betweenCompileWrite</div>
          </li>
          <li>
            <div class="step">beforeWrite</div>
          </li>
          <li>
            <div class="step">write</div>
            <div class="module builtin template css">(CSS, T) options.files possessing outputFileName and outputFileText written to compiledDir</div>
          </li>
          <li>
            <div class="step">afterWrite</div>
            <div class="module require js template">(JS, T) If optimize flag used, base files relating to originally changed file are optimized by r.js</div>
          </li>
          <li>
            <div class="step">complete</div>
          </li>
        </ul>
      </div>
    </div>
    <div class="page-header" id="callback">
      <h1>
        Your Module Callback
        <small><span class="options">when the rubber hits the code</span></small>
      </h1>
    </div>

    <p>So you have registered your module's code to be called in the right spot in the workflow.  You've made sure that only the right extensions will flow through your code.  So what happens when Mimosa calls your callback?</p>

    <p>Your workflow callback is handed 3 arguments.</p>

    <ol>
      <li><code class="options">config</code>: The full <code class="options">mimosa-config</code> enriched with all sorts of useful data beyond the default mimosa-config. The <code class="options">mimosa-config</code> already contains things like the full path to both the source and compiled assets.  And the <code class="options">mimosa-config</code> will contain the config settings for your own module as well.</li>
      <li><code class="options">options</code>: An object that contains information about the asset(s)/extension currently being processed. Inside the options object is a 'files' array that is created early in the workflow. The array contains a list of file objects that are being processed. At different steps of the a Mimosa workflow, those file objects are populated with the inputFileName, the outputFileName, the inputFileText, the outputFileText and some flags to indicate if the asset is a vendor asset, etc. The outputFileText is populated during the <code class="options">compile</code> step.</li>
      <li><code class="options">next</code>: a workflow callback. This callback must be called when your module has finished processing. It tells Mimosa to execute the next step in the workflow. If for some reason your module decides that processing for the current asset/build step needs to stop, the callback can be called passing false. Ex: <code class="options">next(false)</code>. In most cases you do not want to short circuit the workflow.</li>
    </ol>

    <div class="page-header" id="callback">
      <h1>
        Installing Your Module
        <small><span class="options">You've coded it up, now what?</span></small>
      </h1>
    </div>

    <p>So you coded your callbacks, you implemented all the configuration related functions, you know which workflow steps you want your stuff to execute, so how do you let Mimosa know your module exists?  And then how do you make your module available for the world to use?</p>

    <h2>During Development</h2>

    <p>This one is easy.  The <code class="options">mimosa mod:install</code> command handles installing local modules inside Mimosa.  From inside your root module directory, the directory with the <code class="options">package.json</code> file, execute <code class="options">mimosa mod:install</code>.  Once that is done, modify the mimosa-config of a project you are using.  Uncomment/change the modules array to include the name of your module.  Fire up Mimosa and test your module out!</p>

    <h2>Publishing to NPM</h2>

    <p>This one is also easy if you are familiar with <a href="http://npmjs.org/">NPM</a>.  A simple <code class="options">npm publish</code> from the root of your module will install your module to NPM so that anyone can get access to it.  Once it is in NPM, commands like <code class="options">mod:install</code> and <code class="options">mod:search</code> will be able to find it.</p>

    <p>If you have never published to NPM before, then spend a few minutes reading the <a href="https://npmjs.org/doc/developers.html">developer docs</a>.  Just a few simple steps and you are ready to publish.</p>

    <p>If you do create and publish a module, let us know!!!</p>

  </section>

</div>

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/vendor/jquery-1.7.2.min.js"><\/script>')</script>
<script src="js/vendor/bootstrap-collapse.js"></script>
<script src="js/vendor/bootstrap-scrollspy.js"></script>

<!-- scripts concatenated and minified via build script -->
<script src="js/plugins.js"></script>
<script src="js/main.js"></script>
<script type="text/javascript" src="http://platform.twitter.com/widgets.js"></script>
<!-- end scripts -->

<script>
    var _gaq=[['_setAccount','UA-33737130-1'],['_trackPageview']];
    (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
    g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
    s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>
